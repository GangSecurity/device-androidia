#!/usr/bin/env python

import argparse
import ConfigParser
import sys
import os
import re
import argparse
import collections
sys.path.insert(1,'external/pystache')
import pystache
import shutil
import tempfile
import stat
import filecmp
from filecmp import dircmp
pystache.defaults.MISSING_TAGS = 'strict'

# We're assuming '#' is valid to start a comment in all the configs we are amending
# which so far is true.

template = {
None: {
"header" : "# ----------------- BEGIN MIX-IN DEFINITIONS -----------------\n",
"footer" : "# ------------------ END MIX-IN DEFINITIONS ------------------\n",
"source" : "# Source: {}\n",
"line"   : "##############################################################\n",
"warn"   : "# Mix-In definitions are auto-generated by {}\n"
},
"xml" : {
"header" : "<!-- ############# BEGIN MIX-IN DEFINITIONS ############## -->\n",
"footer" : "<!-- ############## END MIX-IN DEFINITIONS ############### -->\n",
"source" : "<!-- Source: {} -->\n",
"line"   : "<!-- ##################################################### -->\n",
"warn"   : "<!-- Mix-In definitions are auto-generated by {} -->\n"
}}

doc_delims = {
"section" : "===",
"option" : "---",
}

# These are the set of product configuration files that are modified by mixins.
# If they are named something else in the actual product directory, the mixin spec
# file should setup the mapping in the "mapping" section
_FILE_LIST = ["BoardConfig.mk", "init.rc", "init.recovery.rc", "fstab", "fstab.recovery", "product.mk",
              "ueventd.rc", "AndroidBoard.mk", "gpt.ini", "flashfiles.ini"]

_PRODUCT_SPEC_FN = "mixins.spec"
_GROUP_SPEC_FN = "mixinfo.spec"
_OPTION_SPEC_FN = "option.spec"
_FILES_SPEC_FN = "files.spec"
_XML_SPEC_FN = "xml.spec"
_DOC_SPEC_FN = "doc.spec"
_EXTRA_DIR = "extra_files"
_EXTRA_DIR_KEY = "_extra_dir"
_INTERNAL_TREE = 'device/intel/mixins/groups'
_RELEASE_INFO_FN = "mixin-groups.doc"
_CHANGE_LOG_FN = "ChangeLog"
_VERSION = "2.0.5"

abort_on_errors = True
policy_errors_found = False

# g_file_tree is used to track files that generated from mixins.
g_file_tree = set()
g_selections = {}
g_deps = {}
# g_target_mixins_tree_backup is used to restore target's mixins tree with '-d' option
g_target_mixins_tree_backup = ' '
g_target_mixins_dir = ' '
g_target_mixins_tree_dir = ' '
g_target_mixins_default_tree_dir = ' '
g_doc_seq_num = 1


class ReadTrackingDict(dict):
    def __init__(self, *args, **kwargs):
        super(ReadTrackingDict, self).__init__(*args, **kwargs)
        self.reads = collections.defaultdict(int)
    def __getitem__(self, key):
        self.reads[key] += 1
        return super(ReadTrackingDict, self).__getitem__(key)
    def unused_keys(self):
        return list(set(self.keys()) - set(self.reads.keys()))


def warning(s):
    sys.stderr.write(s + "\n")
    sys.stderr.flush()


def policy_error(s):
    global policy_errors_found
    sys.stderr.write("ERROR: ")
    warning(s)
    if abort_on_errors:
        sys.exit(1)
    else:
        policy_errors_found = True


def read_spec_file(specfile, cp=None):
    """read a mixin spec file and return a ConfigParser object with its
    definitions. If a ConfigParser is supplied as an argument, it will
    be augmented with the new data"""
    if not cp:
        cp = ConfigParser.SafeConfigParser()
        cp.optionxform = str

    try:
        with open(specfile) as fp:
            cp.readfp(fp)
    except IOError:
        if os.path.islink(specfile):
            policy_error("reading specfile {} which is a symlink,"
                         " maybe it is broken".format(specfile))
        else:
            policy_error("reading specfile {}".format(specfile))

    return cp


def read_mixin_tree(basedir, mixin_tree=None):
    """return a dictionary mapping mixin groups found in a particular
    basedir with a dictionary mapping option names to the directory
    containing their configuration fragments as well as other group-level
    metadata"""

    if not mixin_tree:
        mixin_tree = {}

    groups = [i for i in os.listdir(basedir) if not i.startswith(".")]
    for group in groups:
        assert group not in mixin_tree
        mixin_tree[group] = {}
        groupdir = os.path.join(basedir, group)
        mixin_tree[group]["groupdir"] = groupdir
        mixin_tree[group]["options"] = {}
        mixin_tree[group]["deps"] = set()

        # Check for a mixinfo file in the root of the group directory
        # This is for metadata about the group as a whole. Its presence
        # is optional, many groups won't need it.
        mixinfo = os.path.join(groupdir, _GROUP_SPEC_FN)
        if os.path.exists(mixinfo):
            cp = read_spec_file(mixinfo)

            # "mixinfo.deps" is the set of groups which must be inherited
            # prior to inheriting this mixin, typically because we need the
            # other groups to define certain variables for us
            if cp.has_option("mixinfo", "deps"):
                mixin_tree[group]["deps"] = set(cp.get("mixinfo", "deps").split())

        docinfo = os.path.join(groupdir, _DOC_SPEC_FN)
        if os.path.exists(docinfo):
            check_doc_syntax(docinfo)

        options = [i for i in os.listdir(groupdir) if not i.startswith(".")]
        for option in options:
            assert option not in mixin_tree[group]["options"]

            mixin_tree[group]["options"][option] = {}
            cur_opt = mixin_tree[group]["options"][option]

            opt_dir = os.path.join(groupdir, option)
            if os.path.isdir(opt_dir):
                cur_opt["listdir"] = os.listdir(opt_dir)
            cur_opt["optiondir"] = opt_dir

            cur_opt["deps"] = set()
            cur_opt["defaults"] = {}

            optioninfo = os.path.join(cur_opt["optiondir"], _OPTION_SPEC_FN)
            if option == "default" and os.path.islink(cur_opt["optiondir"]):
                cur_opt["realname"] = os.path.basename(os.path.realpath(cur_opt["optiondir"]))
            else:
                cur_opt["realname"] = option

            if os.path.exists(optioninfo):
                cp = read_spec_file(optioninfo)

                # Options may define their own dependencies just like at the
                # group-level
                if cp.has_option("mixinfo", "deps"):
                    cur_opt["deps"] = set(cp.get("mixinfo", "deps").split())

                if cp.has_section("defaults"):
                    for k, v in cp.items("defaults"):
                        cur_opt["defaults"][k] = v

    return mixin_tree


def get_deps(mixin_tree, group, option):
    return list(mixin_tree[group]["deps"] | mixin_tree[group]["options"][option]["deps"])


def sort_selections(selections, mixin_tree, verbose):
    """sort a group selection based on their dependencies.  Parent groups
    are moved before their childs."""
    sorted_selections = []

    # Re-order the selections so that the "parent" groups appear
    # before their childs. This sort algorithm is stable.
    while selections:
        (group, option, params) = selections.pop(0)
        deps = get_deps(mixin_tree, group, option)
        missing_parents = []
        while deps:
            dep = deps.pop()
            parent_group = [x for x in selections if x[0] == dep]
            if not parent_group:
                continue
            parent_group = parent_group[0]
            missing_parents.append(parent_group)
            for d in get_deps(mixin_tree, parent_group[0], parent_group[1]):
                if d not in deps:
                    deps.append(d)

        while missing_parents:
            parent = missing_parents.pop()
            if verbose:
                print "moving %s before %s" % (parent[0], group)
            sorted_selections.append(parent)
            selections.remove(parent)

        sorted_selections.append((group, option, params))

    for group, option, params in sorted_selections:
        if group == "device-specific":
            index = sorted_selections.index((group, option, params))
            (gr, op, para) = sorted_selections.pop(index)
            sorted_selections.insert(0, (gr, op, para))
            break

    return sorted_selections


def validate_selections(selections, mixin_tree, target, verbose=False):
    """enforce that the set of mixin selections is sane by checking
    the following:
    1) For each group selected, verify that the group exists and that
    the particular selection made within that group also exists
    2) If any groups exist for which there is no selection made, make
    the default selection for that group. If no default exists, report an
    error.
    The selections list may be altered by this function to include
    group default selections"""
    global g_deps

    groups_seen = []
    returned_selections = []
    default_groups = []

    # The spec file may have omitted some groups. If so, pull in their
    # default options, or generate an error if there is no default
    selected = []
    for (group, option, params) in selections:
        selected.append(group)
    unspecified_groups = sorted(set(mixin_tree.keys()) - set(selected))
    for group in unspecified_groups:
        default_groups.append(group)
        if "default" not in mixin_tree[group]["options"]:
            if verbose:
                policy_error("group {} doesn't have a default option!".format(group))
        else:
            params = mixin_tree[group]["options"]["default"]["defaults"]
            coerce_boolean(params)
            selections.append((group, "default", ReadTrackingDict(params)))

    selections = sort_selections(selections, mixin_tree, verbose)

    g_deps[target] = set()
    for (group, option, params) in selections:
        if group in groups_seen:
            policy_error("selection already made for group {}".format(group))
            continue

        groups_seen.append(group)

        if group not in mixin_tree:
            policy_error("no definition found for group {}".format(group))
            continue

        if option not in mixin_tree[group]["options"]:
            policy_error("unknown option {} for group {}".format(option, group))
            continue

        deps = get_deps(mixin_tree, group, option)
        if deps:
            g_deps[target] |= set(deps)

        for dep in deps:
            if dep not in groups_seen:
                policy_error("group {} option {} requires that group {} be selected first".format(group, option, dep))

        defaults = mixin_tree[group]["options"][option]["defaults"]
        for k, v in defaults.iteritems():
            if k not in params:
                params[k] = v

        # Inherit the dependency parameters
        for dep_group, dep_option, dep_params in returned_selections:
            if dep_group in deps:
                dep_params[group] = mixin_tree[group]["options"][option]["realname"]
                g_deps[target].add(group)
                coerce_boolean(dep_params)
                for k, v in dep_params.iteritems():
                    if k not in params:
                        params[k] = v
                params[dep_group] = mixin_tree[dep_group]["options"][dep_option]["realname"]

        coerce_boolean(params)
        returned_selections.append((group, option, params))

    return returned_selections


def clear_file(dest):
    """Return of list of string lines based on the destination file.
    Clear out any existing mixin defintions from the specified file; after this
    is done only the header/footer will remain. If the dest file never had anything
    in it, add the header/footer"""
    output = []
    in_mixin = False
    ever_in_mixin = False
    ftype = get_file_type(dest)

    if os.path.exists(dest):
        with open(dest) as dfile:
            dlines = dfile.readlines()
    else:
        dlines = []

    orig_dlines = dlines[:]

    for line in dlines:
        if not in_mixin:
            output.append(line)
            if line == template[ftype]["header"]:
                in_mixin = True
                ever_in_mixin = True
                output.append(template[ftype]["warn"].format(os.path.basename(sys.argv[0])))
        else:
            if line == template[ftype]["footer"]:
                output.append(line)
                in_mixin = False

    if in_mixin:
        # header with no footer? ok whatever
        output.append(template[ftype]["footer"])

    if not ever_in_mixin:
        output.append(template[ftype]["header"])
        output.append(template[ftype]["warn"].format(os.path.basename(sys.argv[0])))
        output.append(template[ftype]["footer"])

    return orig_dlines, output

warn_vars = [
        "BOARD_KERNEL_CMDLINE",
        "DEVICE_PACKAGE_OVERLAYS",
        "PRODUCT_COPY_FILES",
        "PRODUCT_DEFAULT_PROPERTY_OVERRIDES",
        "PRODUCT_PACKAGES",
        "PRODUCT_PACKAGES_DEBUG",
        "PRODUCT_PACKAGES_ENG",
        "PRODUCT_PACKAGES_TESTS",
        "PRODUCT_PACKAGE_OVERLAYS",
        "PRODUCT_PROPERTY_OVERRIDES",
        ]


def get_file_type(fname):
    if fname.endswith(".xml"):
        return "xml"
    return None


def amend_file(dlines, src, mixinsbase, targetdir, params):
    """Augment the destination lines list with data from the source file provided.
    Assumes we have run clear_file() on dlines at some point beforehand"""
    with open(src) as sfile:
        src_contents = sfile.read()
        if src_contents[-1] != '\n':
            policy_error("No Newline at the end of {}".format(src))

        try:
            slines = pystache.render(src_contents, params)
        except pystache.context.KeyNotFoundError as e:
            policy_error("{} depends on undefined mixin parameter '{}'".format(src, e.key))

    # sanity checks
    if slines.find(mixinsbase) >= 0:
        policy_error("build-time references to paths inside mixin directory are not allowed; {} is invalid".format(src))

    # much faster than previous regexp (\w*)
    m = re.findall('(' + '|'.join(warn_vars) + ')\s*:=', slines)
    if m:
        warning("Non-accumulative assignment to '{}' found in {}".format(m[0], src))

    ftype = get_file_type(src)
    idx = dlines.index(template[ftype]["footer"])
    output = dlines[:idx]
    output.insert(idx, template[ftype]["line"])
    if targetdir in src:
        src = src.replace(targetdir, '.')
    output.insert(idx, template[ftype]["source"].format(src))
    output.insert(idx, template[ftype]["line"])
    output.extend(slines.splitlines(True))
    output.extend(dlines[idx:])
    return output


def coerce_boolean(d):
    for k in d:
        if type(d[k]) == str and d[k].lower() == 'false':
            d[k] = False


def split_params(selections):
    regx_val = re.compile(r"(?<!\\),")  # param's value can contain comma (escaped with backslash)
    res = []
    for group, option_params in selections:
        m = re.match('([^\s(]+)\s*\(([^)]*)\)\s*$', option_params)
        if m is not None:
            option = m.group(1)
            params = dict(map(str.strip, x.replace('\,',',').split('=', 1)) for x in regx_val.split(m.group(2)))
            coerce_boolean(params)
            res.append((group, option, ReadTrackingDict(params)))
        else:
            res.append((group, option_params, ReadTrackingDict()))
    return res


def check_section(section, cp, specfile):
    if not cp.has_section(section):
        policy_error('specfile missing {} section: {}'.format(section, specfile))
        return False
    return True


def extrafiles_from_selections(basedir, selections):

    extrafiles = []
    for (group, option, params) in selections:
        groupdir = os.path.join(basedir, group)

        # Check for a files.spec file in the mixin directory.
        # The section [extrafiles] can be used to expand the
        # _FILE_LIST
        specfile = os.path.join(groupdir, option, _FILES_SPEC_FN)
        if os.path.isfile(specfile) or os.path.islink(specfile):
            cp = read_spec_file(specfile)
            # append all files found in the section avoiding duplicate
            # entries
            if cp.has_section("extrafiles"):
                extra_dir = os.path.join(_EXTRA_DIR, group)
                params[_EXTRA_DIR_KEY] = extra_dir;
                for newfile, comment in cp.items("extrafiles"):
                    if newfile not in extrafiles + _FILE_LIST:
                        extrafiles.append(newfile)

    return extrafiles


def handle_include(specfile):
    """ check for include section in a spec file.
    handle multiple include by recursion.
    return the list of file in the order they must be parsed."""

    cp = read_spec_file(specfile)

    if cp.has_section("include"):
        relative_path = cp.get("include", "file")
        include_path = os.path.join(os.path.dirname(specfile), relative_path)
        return handle_include(include_path) + [specfile]
    return [specfile]


def update_file_if_need(src_fn, dest_fn, dry_run, params=None):

    retval = True

    if os.path.isdir(src_fn):
        for root, dirs, files in os.walk(src_fn):
            if files:
                for f in files:
                    extra_src_fn = os.path.join(root, f)
                    extra_dst_fn = extra_src_fn.replace(src_fn, dest_fn)
                    if not _update_file_if_need(extra_src_fn, extra_dst_fn, dry_run, params):
                                        retval = False
    else:
        if not _update_file_if_need(src_fn, dest_fn, dry_run, params):
            retval = False

    return retval


def _update_file_if_need(src_fn, dest_fn, dry_run, params=None):
    global g_file_tree

    g_file_tree.add(dest_fn)
    retval = True
    if os.path.exists(src_fn):
        with open(src_fn, "r") as sfile:
            dest_contents = sfile.read()
    else:
        dest_contents = " "

    if os.path.exists(dest_fn):
        with open(dest_fn, "r") as dfile:
            orig_dest_contents = dfile.read()
    else:
        orig_dest_contents = " "

    if os.path.islink(src_fn):
        src_real  = os.readlink(src_fn)
        if not os.path.exists(dest_fn):
            if dry_run:
                warning("{} is out of date".format(dest_fn))
                retval = False
            else:
                d = os.path.dirname(dest_fn)
                if not os.path.exists(d):
                    os.makedirs(d)
                print("creating link file {} <-- {}".format(src_real, dest_fn))
                os.symlink(src_real, dest_fn)
        else:
            if os.path.islink(dest_fn):
                dst_real  = os.readlink(dest_fn)
                if src_real != dst_real:
                    if dry_run:
                        warning("{} is out of date".format(dest_fn))
                        retval = False
                    else:
                        os.unlink(dest_fn)
                        print("changing link file {} <-- {}".format(src_real, dest_fn))
                        os.symlink(src_real, dest_fn)
            else:
                if dry_run:
                    warning("{} is out of date".format(dest_fn))
                    retval = False
                else:
                    print("removing file {}".format(dest_fn))
                    if os.path.isdir(dest_fn):
                        shutil.rmtree(dest_fn)
                    else:
                        os.remove(dest_fn)
                    print("creating link file {} <-- {}".format(src_real, dest_fn))
                    os.symlink(src_real, dest_fn)

        return retval

    if dest_contents[-1] == '\n' and params != None and not src_fn.endswith(".bin"):
        try:
            dest_contents = pystache.render(dest_contents, params)
        except pystache.context.KeyNotFoundError as e:
            policy_error("{} depends on undefined mixin parameter '{}'".format(src, e.key))

    if cmp(dest_contents, orig_dest_contents) != 0:
        if dry_run:
            warning("{} is out of date".format(dest_fn))
            retval = False
        else:
            print("updating {}".format(dest_fn))
            d = os.path.dirname(dest_fn)
            if not os.path.exists(d):
                os.makedirs(d)
            with open(dest_fn, "w") as dfile:
                dfile.write(dest_contents)

            src_mode = os.stat(src_fn).st_mode
            dst_mode = os.stat(dest_fn).st_mode
            src_chmod = stat.S_IMODE(src_mode)
            dst_chmod = stat.S_IMODE(dst_mode)
            if(src_chmod != dst_chmod):
                print ("chmod {} {} ".format(oct(src_chmod), dest_fn))
                os.chmod(dest_fn,src_chmod)

    return retval


def generate_release_info_file(basedir, selections, dry_run):
    global g_doc_seq_num
    global g_target_mixins_dir

    retval = True

    release_info = {}
    release_info["table"] = []
    release_info["contents"] = []
    release_info["table"].append("This document describes every mixins group overview and current target's option.\n")
    release_info["table"].append("\n")
    release_info["table"].append("{} Table of Contents\n".format(doc_delims["section"]))
    release_info["table"].append("\n")
    g_doc_seq_num = 1
    for group, option, params in selections:
        docinfo = os.path.join(basedir, group, _DOC_SPEC_FN)
        if os.path.exists(docinfo):
        # table & contents title
            release_info["table"].append("    {} [{}] {}\n".format(doc_delims["section"], g_doc_seq_num, group))
            release_info["contents"].append("{} [{}] {}\n".format(doc_delims["section"], g_doc_seq_num, group))
            g_doc_seq_num += 1
            doc_tree = read_doc_tree(docinfo)
            for section in doc_tree.keys():
                if section == "Options":
                    if option in doc_tree["Options"].keys():
                        release_info["contents"].append("{} {}\n".format(doc_delims["option"], option))
                        release_info["contents"].extend(doc_tree["Options"][option])
                        release_info["contents"].append("\n")
                else:
                    release_info["contents"].extend(doc_tree[section])
                    release_info["contents"].append("\n")
    release_info["table"].append("\n")
    release_info_dlines = release_info["table"] + release_info["contents"]
    release_info_fn = os.path.join(g_target_mixins_dir,  _RELEASE_INFO_FN)
    orig_release_info_dlines = []
    if os.path.exists(release_info_fn):
        with open(release_info_fn) as dfile:
            orig_release_info_dlines = dfile.readlines()

    if cmp(orig_release_info_dlines, release_info_dlines) != 0:
        if dry_run:
            warning("{} is out of date".format(release_info_fn))
            retval = False
        else:
            print("updating {}".format(release_info_fn))
            with open(release_info_fn, "w") as fp:
                fp.writelines(release_info_dlines)

    return retval

def process_spec_file(specfile, dry_run, target, pre_process=False):
    global g_file_tree
    global g_selections
    global g_target_mixins_dir
    global g_target_mixins_tree_dir
    global g_target_mixins_default_tree_dir

    filelist = handle_include(specfile)
    cp = None
    for f in filelist:
        cp = read_spec_file(f, cp)

    if False in (
            check_section("main", cp, specfile),
            check_section("groups", cp, specfile)
            ):
        return

    mixinsctl = False
    mixinsrel = False
    cp1 = read_spec_file(specfile)
    if cp1.has_option("main", "mixinsctl") and cp1.get("main", "mixinsctl").lower() == "true":
        mixinsctl = True

    if cp1.has_option("main", "mixinsrel") and cp1.get("main", "mixinsrel").lower() == "true":
        mixinsrel = True

    product_dir = os.path.dirname(specfile)
    if product_dir == '':
        product_dir = '.'

    basedir = cp.get("main", "mixinsdir")
    if basedir.startswith('.'):
        basedir = os.path.join(product_dir, basedir.replace('./',''))

    if not os.path.exists(basedir) or pre_process or not mixinsrel:
        basedir = _INTERNAL_TREE

    mixin_tree = read_mixin_tree(basedir)
    selections = split_params(cp.items("groups"))

    if not dry_run:
        print 'mixinsdir: {}'.format(basedir)
        print("processing {}".format(specfile))

    # After this, all default selections should be populated
    # and the selections should be sane
    selections = validate_selections(selections, mixin_tree, target, not dry_run)
    g_selections[target] = selections[:]

    #TODO: need to separate preprocess into another function
    if pre_process:
        return

    file_map = {}
    retval = True
    extrafiles = extrafiles_from_selections(basedir, selections)

    # If a file is in [extrafiles] section of mixins.spec
    # but not already in _FILE_LIST or extrafiles, add it to extrafile list
    if cp.has_section("extrafiles"):
        for newfile, comment in cp.items("extrafiles"):
            if newfile not in extrafiles + _FILE_LIST:
                extrafiles.append(newfile)

    # Set up the file map since the config files in the product directory
    # may have slightly different names than what is in _FILE_LIST
    for fname in _FILE_LIST:
        if cp.has_option("mapping", fname):
            file_map[fname] = cp.get("mapping", fname).split()
        else:
            file_map[fname] = [fname]

    for src, dests in file_map.iteritems():
        for dest in dests:
            dest_fn = os.path.join(product_dir, dest)

            orig_dest_lines, dest_lines = clear_file(dest_fn)
            if mixinsctl and len(dest_lines) != 3:
                policy_error("Not allowed to modify {} when mixinsctl set to true!".format(os.path.join(product_dir,dest)))

            # Now check all the groups to see if they have a configuration
            # fragment to insert into the destination file
            for group, option, params in selections:
                cur_opt = mixin_tree[group]["options"][option]

                optdir = cur_opt["optiondir"]

                # Any given file can have multiple fragments. We first
                # look for <frag>.1, <frag>.2, ... <frag>.9, <frag>
                # This is useful for when several mixin options have mostly
                # the same data except for maybe a few lines; you can
                # avoid copypasting a lot of stuff by using this feature
                # and symbolic links for the common bits.
                dsrc, fsrc = os.path.split(src)
                flist = [f for f in cur_opt["listdir"] if f.startswith(fsrc) and (dsrc in optdir)]
                fraglist = [f for f in flist if len(f) == len(fsrc) + 2 and f[-2] == '.' and f[-1].isdigit()]
                if fraglist:
                    fraglist.sort()
                    for f in fraglist:
                        dest_lines = amend_file(dest_lines, os.path.join(optdir, f), basedir, product_dir, params)
                if fsrc in flist:
                    dest_lines = amend_file(dest_lines, os.path.join(optdir, fsrc), basedir, product_dir, params)

            if len(dest_lines) > 3 and dest_fn not in g_file_tree:
                g_file_tree.add(dest_fn)

            if cmp(dest_lines, orig_dest_lines) != 0:
                if dry_run:
                    warning("{} is out of date".format(dest_fn))
                    retval = False
                else:
                    print("updating {}".format(dest_fn))
                    with open(dest_fn, "w") as fp:
                        fp.writelines(dest_lines)

    for group, option, params in selections:
        cur_opt = mixin_tree[group]["options"][option]
        optdir = cur_opt["optiondir"]
        specfile = os.path.join(optdir, _FILES_SPEC_FN)
        file_map = {}
        if os.path.isfile(specfile) or os.path.islink(specfile):
            cp = replace_spec_params(specfile, params)

            if cp.has_section("mapping"):
                for fn, mfn in cp.items("mapping"):
                    file_map[fn] = mfn

            if cp.has_section("extrafiles"):
                extra_dir = os.path.join(_EXTRA_DIR, group)
                dest_dir = os.path.join(product_dir, extra_dir)
                if not os.path.exists(dest_dir):
                    os.makedirs(dest_dir)
                for newfile, comment in cp.items("extrafiles"):
                    src_fn = os.path.join(optdir, newfile)
                    if newfile in file_map.keys():
                        newfile = file_map[newfile]
                    dest_fn = os.path.join(dest_dir, newfile)
                    fn = os.path.join(product_dir, newfile)
                    if os.path.exists(fn) and not dry_run:
                        print("removing extra file {} in product dir".format(fn))
                        if os.path.islink(fn):
                            os.unlink(fn)
                        elif os.path.isdir(fn):
                            shutil.rmtree(fn)
                        else:
                            os.remove(fn)
                    if not update_file_if_need(src_fn, dest_fn, dry_run, params):
                        retval = False

            if cp.has_section("devicefiles"):
                for newfile, comment in cp.items("devicefiles"):
                    src_fn = os.path.join(optdir, newfile)
                    if newfile in file_map.keys():
                        newfile = file_map[newfile]
                    dest_fn = os.path.join(product_dir, newfile)
                    if not update_file_if_need(src_fn, dest_fn, dry_run, params):
                        retval = False

    for group, option, params in selections:
        unused = params.unused_keys()
        if unused:
            policy_error('Unnecessary parameters {} given for mixin option'
                         ' "{}: {}"'.format(unused, group, option))

    # Clear unused files & folders under product dir
    if not dry_run and mixinsctl:
        local_file_tree = set()
        for root, dirs, files in os.walk(product_dir):
            # Exclude mixins folder
            if files and "mixins" not in root:
                for f in files:
                    fn = os.path.join(root, f)
                    local_file_tree.add(fn)
        delta = local_file_tree - g_file_tree
        for f in delta:
            # exclude mixins spec file
            if not f.endswith(_PRODUCT_SPEC_FN):
                print("removing unused file {}".format(f))
                os.remove(f)

        delete_folder_recursively_if_empty(product_dir)

    if not dry_run and not mixinsrel and not pre_process and g_target_mixins_dir != os.path.dirname(_INTERNAL_TREE) and os.path.exists(g_target_mixins_dir):
        print ("removing {}'s mixins folder...".format(target))
        shutil.rmtree(g_target_mixins_dir)

    if mixinsrel and not pre_process:
        if g_target_mixins_tree_dir == g_target_mixins_default_tree_dir:
            if not generate_release_info_file(basedir, selections, dry_run):
                retval = False

        # mixin script & ChangeLog file
        if os.path.exists(_INTERNAL_TREE):
            target_mixin_fn = os.path.join(g_target_mixins_dir, os.path.basename(sys.argv[0]))
            if not update_file_if_need(sys.argv[0], target_mixin_fn, dry_run):
                retval = False

            change_log_fn = os.path.join(os.path.dirname(_INTERNAL_TREE), _CHANGE_LOG_FN)
            target_change_log_fn = os.path.join(g_target_mixins_dir, _CHANGE_LOG_FN)
            if not update_file_if_need(change_log_fn, target_change_log_fn, dry_run):
                retval = False

    return retval


def find_all_spec_files(basepath):
    """find all the mixin spec files underneath the specified
    directory (typically device/) and return a list of paths to
    them"""
    ret = []
    for root, dirs, files in os.walk(basepath):
        if "mixins.spec" in files:
            ret.append(os.path.join(root, _PRODUCT_SPEC_FN))
    return ret


def split_lines(dlines, delimiter):
    """split lines based on delimiter and return a dic
    """
    d = {}

    delimiter_index = []
    # Find all delimter lines
    for i, line in enumerate(dlines):
        if line.startswith(delimiter):
            delimiter_index.append(i)

    # eg: "=== section_name", space character is needed
    for i, index in enumerate(delimiter_index):
        s = dlines[index].strip()
        if s.find(' ') == -1:
            policy_error('space character is needed between delimter and section name: "{}"'.format(s))
            continue
        l = s.split()
        title = l[1]
        if i < len(delimiter_index)-1:
            content = dlines[index+1: delimiter_index[i+1]-1]
        else:
            content = dlines[index+1:]
        d[title] = content

    return d


def read_doc_tree(fn):

    with open(fn) as dfile:
        dlines = dfile.readlines()

    doc_tree = split_lines(dlines, doc_delims["section"])
    if "Options" in doc_tree.keys():
        d = split_lines(doc_tree["Options"], doc_delims["option"])
        doc_tree["Options"] = d

    return doc_tree


def check_doc_syntax(doc):

    doc_tree = read_doc_tree(doc)
    sections = ["Overview", "Options"]

    for section in sections:
        if section not in doc_tree.keys():
            policy_error('specfile missing {} section or {} has syntax error: {}'.format(section, section, doc))

        elif section == "Options":
            if not doc_tree["Options"].keys():
                policy_error('Options section missing valid option description: {}'.format(doc))


def delete_folder_recursively_if_empty(path):

    if not os.path.isdir(path):
        return

    files = os.listdir(path)
    if len(files):
        for f in files:
            fn = os.path.join(path, f)
            if os.path.isdir(fn):
                delete_folder_recursively_if_empty(fn)

    # if folder empty, delete it
    files = os.listdir(path)
    if len(files) == 0:
        print "removing empty folder {}".format(path)
        os.rmdir(path)


def replace_spec_params(specfile, params):

    cp = None
    with open(specfile) as sfile:
        src_contents = sfile.read()
        if src_contents[-1] != '\n':
            policy_error("No Newline at the end of {}".format(specfile))
        try:
            slines = pystache.render(src_contents, params)
        except pystache.context.KeyNotFoundError as e:
            policy_error("{} depends on undefined mixin parameter '{}'".format(src, e.key))
        temp_spec = tempfile.mkstemp(prefix='mixins-', text=True)[1]
        with open(temp_spec, "w") as dfile:
            dfile.writelines(slines)
        cp = read_spec_file(temp_spec)
        os.remove(temp_spec)

    return cp


def is_builtin_file(fn):

    for f in _FILE_LIST + [_OPTION_SPEC_FN, _FILES_SPEC_FN]:
        if fn.startswith(f):
            return True

    return False


def copy_one_option(opt_src, opt_dst, params):

    # Create default option in external mixins group if internal doesn't include
    if not os.path.exists(opt_src) and os.path.basename(opt_src) in ["default", "false"] :
        if not os.path.exists(opt_dst):
            os.makedirs(opt_dst)
            open("{}/empty_dir".format(opt_dst), "w").close()
        return

    f_lists = [i for i in os.listdir(opt_src) if is_builtin_file(i)]
    d_lists = []

    specfile = os.path.join(opt_src, _FILES_SPEC_FN)
    if os.path.isfile(specfile) or os.path.islink(specfile):
        cp = replace_spec_params(specfile, params)

        if cp.has_section("extrafiles"):
            for newfile, comment in cp.items("extrafiles"):
                fn = os.path.join(opt_src, newfile)
                if os.path.isfile(fn):
                    f_lists.append(newfile)
                elif os.path.isdir(fn):
                    d_lists.append(newfile)

        if cp.has_section("devicefiles"):
            for newfile, comment in cp.items("devicefiles"):
                fn = os.path.join(opt_src, newfile)
                if os.path.isfile(fn):
                    f_lists.append(newfile)
                elif os.path.isdir(fn):
                    d_lists.append(newfile)

    if not os.path.exists(opt_dst):
        os.makedirs(opt_dst)

    for d in d_lists:
        dir_src = os.path.join(opt_src, d)
        dir_dst = os.path.join(opt_dst, d)
        if os.path.exists(dir_dst):
            dcmp = dircmp(dir_src, dir_dst)
            if dcmp.diff_files or dcmp.left_only or dcmp.right_only:
                shutil.rmtree(dir_dst)
                shutil.copytree(dir_src, dir_dst, symlinks=True)
        else:
            shutil.copytree(dir_src, dir_dst, symlinks=True)

    for f in f_lists:
        fn_src = os.path.join(opt_src, f)
        fn_dst = os.path.join(opt_dst, f)
        if os.path.exists(fn_dst):
            if not filecmp.cmp(fn_src, fn_dst):
                shutil.copy(fn_src, fn_dst)
        else:
            dirname = os.path.dirname(fn_dst)
            if not os.path.exists(dirname):
                os.makedirs(dirname)
            shutil.copy(fn_src, fn_dst)

    # Don't add empty folder as mixins will delete empty folder when mixinsctl is set.
    files = os.listdir(opt_dst)
    if len(files) == 0:
        open("{}/empty_dir".format(opt_dst), "w").close()


def copy_one_group(group, option, params, mixin_dir, output_dir):

    group_src = os.path.join(mixin_dir, group)
    group_dst = os.path.join(output_dir, group)

    options_copy = set()
    options_copy.add(option)
    options_copy.add("default")
    options_copy.add("false")
    for opt in options_copy:
        opt_src = os.path.join(group_src, opt)
        opt_dst = os.path.join(group_dst, opt)
        if os.path.islink(opt_src):
            opt_src_real  = os.path.realpath(opt_src)
            realname = os.path.basename(opt_src_real)
            opt_dst_real = os.path.join(group_dst, realname)
            copy_one_option(opt_src_real, opt_dst_real, params)
            if not os.path.exists(opt_dst):
                os.symlink(realname, opt_dst)
        else:
            copy_one_option(opt_src, opt_dst, params)

     # Copy group meta file
    mixinfo_src = os.path.join(group_src, _GROUP_SPEC_FN)
    mixinfo_dst = os.path.join(group_dst, _GROUP_SPEC_FN)
    if os.path.exists(mixinfo_src):
        shutil.copy(mixinfo_src, mixinfo_dst)

    # doc.spec process
    docinfo_src = os.path.join(group_src, _DOC_SPEC_FN)
    if os.path.exists(docinfo_src):
        doc_tree_src = read_doc_tree(docinfo_src)
        dlines = []
        for section in doc_tree_src.keys():
            if section == "Options":
                dlines.append("{} {}\n".format(doc_delims["section"], section))
                dlines.append("\n{} {}\n".format(doc_delims["option"], option))
                if option in doc_tree_src["Options"].keys():
                    dlines.extend(doc_tree_src["Options"][option])
            else:
                dlines.append("{} {}\n".format(doc_delims["section"], section))
                dlines.extend(doc_tree_src[section])
            dlines.append("\n")

        docinfo_dst = os.path.join(group_dst, _DOC_SPEC_FN)
        if os.path.exists(docinfo_dst):
            with open(docinfo_dst) as dfile:
                dst_lines = dfile.readlines()
            doc_tree_dst = read_doc_tree(docinfo_dst)
            if option not in doc_tree_dst["Options"].keys() and option in doc_tree_src["Options"].keys():
                dst_lines.append("\n{} {}\n".format(doc_delims["option"], option))
                dst_lines.extend(doc_tree_src["Options"][option])
                with open(docinfo_dst, "w") as dfile:
                    dfile.writelines(dst_lines)
        else:
            with open(docinfo_dst, "w") as dfile:
                dfile.writelines(dlines)


def generate_target_mixin_tree(target, dry_run):
    global g_selections
    global g_deps
    global g_target_mixins_tree_backup
    global g_target_mixins_tree_dir

    if os.path.exists(g_target_mixins_tree_dir):
        if dry_run:
            # Backup target's original mixins tree
            g_target_mixins_tree_backup = os.path.join(tempfile.mkdtemp(), "mixins/groups")
            shutil.copytree(g_target_mixins_tree_dir, g_target_mixins_tree_backup, symlinks=True)

        #shutil.rmtree(g_target_mixins_tree_dir)

    for group, option, params in g_selections[target]:
        # Only copy valid default option
        if group not in g_deps[target] and option == "default":
            optdir = os.path.join(_INTERNAL_TREE, group, option)
            if not set(os.listdir(optdir)) & set(_FILE_LIST):
                continue
        copy_one_group(group, option, params, _INTERNAL_TREE, g_target_mixins_tree_dir)


def sf_pre_process(sf, target, dry_run):
    """check whether mixins release is enabled, if enabled,
    generate target's mixins groups under target folder.
    """
    need_restore = False
    cp = read_spec_file(sf)
    if cp.has_option("main", "mixinsrel"):
        if cp.get("main", "mixinsrel").lower() == "true":
            process_spec_file(sf, True, target, True)
            generate_target_mixin_tree(target, dry_run)
            if dry_run:
                need_restore = True
            return need_restore


    return False


def main(dry_run=False, sfiles=None, warn_only=False, doc_files=None, check_version=False):
    global abort_on_errors
    global g_file_tree
    global g_target_mixins_tree_backup
    global g_target_mixins_dir
    global g_target_mixins_tree_dir
    global g_target_mixins_default_tree_dir

    ret = 0
    abort_on_errors = not warn_only
    out_of_sync = False

    if check_version:
        print "Mixins {}".format(_VERSION)
        return ret

    if doc_files:
        for doc in doc_files:
            check_doc_syntax(doc)
        if policy_errors_found:
            warning("Doc spec files have syntax issues")
            ret = 2
        else:
            print("Doc spec files syntax check PASS")
        return ret

    if not sfiles:
        sfiles = find_all_spec_files("device")

    for sf in sfiles:
        g_file_tree.clear()
        target_dir = os.path.dirname(sf)
        # default target mixins tree dir is under target directory
        g_target_mixins_default_tree_dir = os.path.join(target_dir, "mixins/groups")
        g_target_mixins_tree_dir = g_target_mixins_default_tree_dir
        target = os.path.basename(target_dir)
        target_mixins_dir_exists = False
        need_restore = False
        filelist = handle_include(sf)
        cp = None
        for f in filelist:
            cp = read_spec_file(f, cp)
        mixinsdir = cp.get("main", "mixinsdir")
        if not mixinsdir.startswith('.'):
            g_target_mixins_tree_dir = mixinsdir
        g_target_mixins_dir = os.path.dirname(g_target_mixins_tree_dir)
        if os.path.exists(g_target_mixins_dir):
           target_mixins_dir_exists = True
        if os.path.exists(_INTERNAL_TREE):
            need_restore = sf_pre_process(sf, target, dry_run)
        if not process_spec_file(sf, dry_run, target):
            out_of_sync = True

        # Restore target's original mixins tree
        if need_restore and os.path.exists(_INTERNAL_TREE):
            if target_mixins_dir_exists:
                shutil.rmtree(g_target_mixins_tree_dir)
                shutil.copytree(g_target_mixins_tree_backup, g_target_mixins_tree_dir, symlinks=True)
                shutil.rmtree(g_target_mixins_tree_backup)
            elif os.path.exists(g_target_mixins_dir):
                shutil.rmtree(g_target_mixins_dir)

    if out_of_sync:
        warning("Board configs are out of sync with mixins, please run mixin-update")
        ret = 3

    if policy_errors_found:
        warning("Some spec files have policy issues")
        ret = 2

    return ret


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Update board configurations with mixin data based on spec file")
    parser.add_argument("-d", "--dry-run",
            help="Don't make any actual changes, exit nonzero if something needs to be updated",
            action="store_true")
    parser.add_argument("-s", "--spec",
            help="Read a specific spec file. Can be called multiple times. Defaults to scanning the tree under device/intel/ for spec files",
            action="append")
    parser.add_argument("-w", "--warn-only",
            help="Generate warnings instead of fatal errors for spec file policy violations",
            action="store_true")

    parser.add_argument("-c", "--check",
            help="Read a doc spec file and check its syntax",
            action="append")

    parser.add_argument("-v", "--version",
            help="Check mixins version",
            action="store_true")

    args = parser.parse_args()

    ret = main(args.dry_run, args.spec, args.warn_only, args.check, args.version)
    sys.exit(ret)
